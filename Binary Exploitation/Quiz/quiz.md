# Quiz

**Kategori:** Binary Exploitation  

---
## Deskripsi Singkat Soal

Disediakan sebuah file bernama `quiz` dan service:

```bash
nc 43.128.69.211 13004
````

Saat terkoneksi, program akan menampilkan:

```text
How much is your money?
```

Tujuan: menemukan input yang membuat program mencetak flag dari `flag.txt`.

---
## Analisis Singkat

Dari dekompilasi (`dogbolt.org`), fungsi `main`:

```c
undefined8 main(void)
{
  ulong local_28;     // unsigned long
  ...
  puts("How much is your money?");
  __isoc99_scanf("%lld", &local_28);

  if (100 < (long)local_28) {
    puts("You cannot have more than 100 Rupiaz as a student!");
    exit(1);
  }

  if (local_28 < 0xf4241) {   // 0xf4241 = 1.000.001
    puts("Your money is not enough for a flag :(");
    puts("You need 1 million rupiaz for a flag!");
    puts("It's only for admin!");
    exit(1);
  }

  puts("It... Can't be!!!");
  local_18 = fopen("flag.txt","r");
  ...
}
```

Poin penting:

1. **Tipe vs format input tidak cocok**
    - `local_28`: `unsigned long`
    - `scanf("%lld", &local_28)`: baca sebagai **signed long long**  
        → nilai negatif disimpan sebagai unsigned tanpa mengubah bit.
    
2. **Perbandingan pertama (signed)**
    ```c
    if (100 < (long)local_28)
    ```
    - Dibandingkan sebagai **signed** → nilai negatif dianggap kecil.
    
3. **Perbandingan kedua (unsigned)**
    ```c
    if (local_28 < 0xf4241)
    ```
    - Dibandingkan sebagai **unsigned** → bit pattern negatif jadi angka **sangat besar**.
        
4. **Syarat menuju flag**  
    Untuk mencapai `fopen("flag.txt","r")`, kedua kondisi harus **false**:
    - `100 < (long)local_28` → false
    - `local_28 < 0xf4241` → false
        

Hal ini tidak bisa dicapai dengan bilangan positif biasa, tapi bisa dengan **bilangan negatif** (karena mismatch signed/unsigned).

---
## Langkah Penyelesaian

1. **Coba input positif**
    - Input kecil (mis. `20`):
        - Kondisi pertama : 20 > 100 → lolos if pertama
        - Kondisi kedua: 20 `< 1.000.001` → masuk if kedua → “not enough”
    - Input besar (mis. `120`, `1000000`):
        - Kondisi pertama: 20 `> 100` → masuk if pertama → “You cannot have more than 100”
    
    ➜ Input positif selalu berhenti di salah satu `if`.
    
2. **Gunakan nilai negatif**
    Dari kode:
    ```c
    ulong local_28;
    __isoc99_scanf("%lld", &local_28);
    ```
    Contoh input: `-1`
    - Sebagai signed 64-bit: `-1` → bit `0xFFFFFFFFFFFFFFFF`
    - Dibaca sebagai unsigned: `18446744073709551615`
        
    Cek kondisi:
    ```c
    // Kondisi 1 (signed)
    (long)local_28 = -1;
    100 < -1  → false
    
    // Kondisi 2 (unsigned)
    local_28 = 18446744073709551615;
    local_28 < 0xf4241 (1000001) → false
    ```
    
    Dua-duanya `false` → program lanjut ke:
    ```c
    puts("It... Can't be!!!");
    fopen("flag.txt","r");
    ```

---
## Flag

```text
scsc26{Integer_Und3R_fl0W_0v3rFl0W}
```